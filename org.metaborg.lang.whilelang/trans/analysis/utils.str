module analysis/utils

strategies
  add-annos: (t{},t*) -> t{t*}
  add-annos: (t{t1*},t2*) -> t{t3*} where t3* := [t1*,t2*]
//  add-label: t -> <add-annos>(t,[Anno("labels", [<newname> ""])])
//  add-proc-labels = !(<id>,[Anno("labels", [<newname> "n", <newname> "x"])]);add-annos
//  add-call-labels = !(<id>,[Anno("labels", [<newname> "c", <newname> "r"])]);add-annos
  // Annotates the labeled AST with extra analysis annotations
  add-analysis-annos(s|name,o,c) = topdown(try(\_{Anno("labels", l*)} ->
    <add-annos> (<id>, [Anno(name, <map(\l -> <tmap((hashtable-get(|l);s) <+ !"")> (o,c)\)> l*)])
  \))
  // Shows the analysis tables as lists
  // Takes same arguments as add-analysis-annos so they can be switched easily
  show-analysis-tables(s|name,o,c): _ -> <tmap(hashtable-getlist;map((id,s <+ !"")))> (o,c)
  
  // change edge pairs to pairs of the from label and all the to labels
  edges-to-assocs: [] -> []
  edges-to-assocs: [(from,to)|t] -> [(from,[to|to'])|<edges-to-assocs>t']
    where (to',t') := <partition(?(from,<id>))> t
  
  // turn labeled things into an association list of {label -> thing}
//  labeled-to-map = mapconcat(
//     \b{Anno("labels",[l])} -> [(l,b)]\
//  <+ \b{Anno("labels",l)} -> [(l,b) | <map(!(<id>,b))> l]\
//  )
  
  hashtable-from-edges: kv* -> <new-hashtable(|<length>, 75)
                               ;hashtable-putlist(hashtable-push|kv*)>
  hashtable-map(s) = hashtable-getlist;map(s);hashtable-init
  
  iset-init: list -> <new-iset;iset-addlist(|list)>
  
  iset-copy = iset-elements;iset-init
  
  iset-subtract(|set2): set1 -> set1
    with <iset-elements;map(\elem -> <iset-remove(|elem)> set1\)> set2 
  
  treverse = TupleToList;reverse;ListToTuple
  
  // extraction of labels from a inter-procedure four-tuple 
  call-lab = ?(<id>,_,_,_)
  entr-lab = ?(_,<id>,_,_)
  exit-lab = ?(_,_,<id>,_)
  retu-lab = ?(_,_,_,<id>)
  
  // put an augmented flow in hashtables 
  aug-flow-hash = (hashtable-from-edges, hashtable-init)
  
rules // call helper, adapted from https://github.com/metaborg/relations/blob/master/relations/trans/_editor/generate.str
  
  call-ignore-output: (program, args) -> ()
    with
      Stream(instream)   := <stdin-stream>;
      Stream(filestream) := <fopen> ("stdout.txt", "w");
      Stream(filestream2):= <fopen> ("stderr.txt", "w")
    with
      _ := <prim("SSL_EXT_call", program, args, instream, filestream, filestream2)>
    with
      <fclose>filestream;
      <fclose>filestream2;
      <delete-file>"stdout.txt";
      <delete-file>"stderr.txt"
  
  
  delete-file: a -> None()
    with
      if file-exists then remove-file end
  