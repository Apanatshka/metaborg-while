module static-semantics

imports
  signatures/-
  signatures/desugared/-

signature
  sorts Type  ArtificialName
  constructors
    Int : Type
    Main : ArtificialName

rules

init ^ (scope) :=
  new scope.

Def [[ Def(n) ^ (scope) ]] :=
  Var { n } <- scope,
  Var { n } : Int().

[[ DesugaredRoot(procs, main) ^ (globalscope) ]] :=
  filescope ---> globalscope,
  [[ procs ^ (filescope) ]],
  [[ main ^ (filescope) ]],
  new filescope.

[[ Main(defs, s, outs) ^ (filescope) ]] :=
  Proc { Main() } <- filescope,
  Proc { Main() } ===> mainscope,
  mainscope ---> filescope,
  Map1(Def) [[ defs ^ (mainscope) ]],
  Map1 [[ outs ^ (mainscope) ]],
  [[ s ^ (mainscope) ]],
  new mainscope.

[[ ProcSeq(p, t) ^ (scope) ]] :=
  [[ p ^ (scope) ]],
  [[ t ^ (scope) ]].

[[ ProcSeqEnd() ^ (_) ]].

[[ Procedure(name, ins, out, defs, body, outs) ^ (filescope) ]] :=
  Proc { name } <- filescope,
  Proc { name } ===> procedurescope,
  procedurescope ---> filescope,
  Map1 [[ ins ^ (procedurescope) ]],
  [[ out ^ (procedurescope) ]],
  Map1(Def) [[ defs ^ (procedurescope) ]],
  Map1 [[ outs ^ (mainscope) ]],
  [[ body ^ (procedurescope) ]],
  new procedurescope.

[[ Output(n) ^ (scope) ]] :=
  Var { n } -> scope.

[[ Val(in) ^ (procedurescope) ]] :=
  Var { in } <- scope,
  Var { in } : Int().

[[ Res(out) ^ (procedurescope) ]] :=
  Var { out } <- scope,
  Var { out } : Int().

[[ Skip() ^ (scope) ]].

[[ Assign(Var(n), expr) ^ (scope) ]] :=
  Var { n } -> scope,
  Var { n } |-> _,
  [[ expr ^ (scope) ]].

[[ Seq(st1, st2) ^ (scope) ]] :=
  [[ st1 ^ (scope) ]],
  [[ st2 ^ (scope) ]].

[[ IfThenElse(c, t, e) ^ (scope) ]] :=
  [[ c ^ (scope) ]],
  [[ t ^ (scope) ]],
  [[ e ^ (scope) ]].

[[ While(c, b) ^ (scope) ]] :=
  [[ c ^ (scope) ]],
  [[ b ^ (scope) ]].

[[ Ref(n) ^ (scope) ]] :=
  Var { n } -> scope,
  Var { n } |-> _.

[[ Num(_) ^ (scope) ]].

[[ here@BinOp(Add(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Sub(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Mul(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Div(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ True() ^ (scope) ]].
[[ False() ^ (scope) ]].

[[ here@UnOp(Not(), e) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e ^ (scope) ]].

[[ here@BinOp(And(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Or(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Eq(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Gt(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Gte(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Lt(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].

[[ here@BinOp(Lte(), e1, e2) ^ (scope) ]] :=
//  scope ---> scope,
//  new scope,
//  refs is set R(scope),
  [[ e1 ^ (scope) ]],
  [[ e2 ^ (scope) ]].
