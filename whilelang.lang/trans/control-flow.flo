module control-flow

ast root DesugaredRoot(_, _)

cfg DesugaredRoot(procs, main) = cfg main, cfg procs

cfg ProcSeq(p, tail) = cfg p, cfg tail

cfg ProcSeqEnd() = entry -> exit

cfg root Procedure(_, _, _, _, s) = start -> cfg s -> end

cfg root m@Main(_, s) = start -> cfg s -> m -> end

cfg this@Assign(_, e) =
  entry -> cfg e -> this -> exit

cfg Skip() = entry -> exit

cfg Seq(s1,s2) = entry -> cfg s1 -> cfg s2 -> exit

cfg IfThenElse(c, t, e) =
  entry -> cfg c -> cfg t -> exit, 
           cfg c -> cfg e -> exit

cfg While(e, s) =
  entry -> cfg e -> cfg s -> cfg e -> exit

cfg e@Ref(_) = entry -> e -> exit
cfg e@Num(_) = entry -> e -> exit
cfg e@Add(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Sub(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Mul(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Div(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@True() = entry -> e -> exit
cfg e@False() = entry -> e -> exit
cfg e@Not(s) = entry -> cfg s -> e -> exit
cfg e@And(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Or(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Eq(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Gt(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Gte(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Lt(l,r) = entry -> cfg l -> cfg r -> e -> exit
cfg e@Lte(l,r) = entry -> cfg l -> cfg r -> e -> exit

prop live: MaySet(term) // should be MaySet(name) but that has no effect yet

live(Ref(n) -> next) = live(next) \/ {n}

live(Assign(Var(n), _) -> next) = live(next) \ {n}

live(Main(vars, _) -> next) = live(next) \/ Set.fromList(vars)

live(_ -> next) = live(next)

//live(end) = {}